# Vite vs Webpack: PURE комментарии

В продолжении поста “нюанс с React.memo” и перед темой про `sideEffects` хочется ещё немного накинуть про разницу в сборке проекта с помощью Vite и Webpack.

Расширим прошлый пример до:

```javascript
// Простой компонент
export { Test } from './test';

// Ещё один простой компонент
export { TestRaw } from './test-raw';

// Компонент обёрнутый в React.memo
export { TestMemo } from './test-memo';

// Компонент обёрнутый в React.forwardRef
export { TestRef } from './test-ref';

// Ленивый компонент
// через функцию поверх React.lazy
export { LazyTest } from './lazy';
```

_Примечание: Из всего этого, в коде используется только компонент Test._

Собрав проект мы получаем следующие результаты:

Webpack оставил в бандле только `Test` и сайд эффекты, а все остальные компоненты и вспомогательные функции он удалил.

Vite же оставил всё кроме компонента `TestRaw`…

Ну что ж, если вы читали прошлый пост, то результат для вас ожидаем. Но возможно вас удивит тот момент, что в обоих случаях файл `lazy.js` (в котором лежит тот самый ленивый компонент `LazyTest`) присутствует в сборке. С Vite всё понятно, но почему Webpack оставил этот файл хотя компонент не используется? Давайте разбираться.

На самом деле собирается весь код до которого сборщик может дотянуться. Попутно проставляются специальные `__PURE__` комментарии-подсказки, например как в этом случае:

```javascript
// Фрагмент из сборки от Webpack:
const TestMemo = /*#__PURE__*/(null && (memo(() => {
  return /*#__PURE__*/_jsx("p", {
    children: "MEMO"
  });
})));

// Для сравнения, тот же фрагмент от Vite:
react.memo(() => {
  return /* @__PURE__ */ jsxRuntime.jsx("p", {
    children: "MEMO"
  });
});
```

Далее, в дело вступает минификатор кода, именно он и удаляет всё что посчитает необходимым (что по его мнению не используется). И PURE комментарии играют в этом процессе важную роль, сообщая что следующий код “чистый” и может быть удалён, если не используется.

Но и тут Vite действует иначе… удаление не используемого кода происходит до этапа минификации (обратите внимание, он удалил константу TestMemo).

Что касается вопроса про `lazy.js`, то минификатор работает лишь с содержимым файлов, поэтому файл остаётся в бандле, хотя и не используется.

П.С. Кстати, именно поэтому анализаторы бандла могут показывать то, чего в бандле на самом деле нет.
